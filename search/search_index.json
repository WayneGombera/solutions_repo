{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Projectile Motion Simulation 1. Introduction Purpose of the Study In this report we will be studying the motion of a projectile. The goal of this study is to develop a clear mathematical model that describes how different factors, like the angle of launch and initial velocity, affect the range and trajectory of the projectile. 2. Theoretical Foundation 2.1 Governing Equations of Motion There are basic equations that govern the motion of a projectile. These equations describe the horizontal and vertical displacements over time, considering an initial velocity and launch angle. Derivation of Governing Equations of Motion 1. Horizontal Motion In projectile motion, the horizontal velocity remains constant (neglecting air resistance). The horizontal displacement is given by: \\[ x = v_0 \\cos(\\theta) t \\] where: - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the launch angle, - \\(t\\) is time. 2. Vertical Motion The vertical motion is influenced by gravity, leading to the following equation: \\[ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] where: - \\(g\\) is the acceleration due to gravity. The velocity in the vertical direction changes over time: \\[ v_y = v_0 \\sin(\\theta) - g t \\] The time of flight, range, and maximum height can be derived from these equations. 3. Family of Solutions The trajectory of a projectile depends on two initial conditions: the initial velocity \\(v_0\\) and the launch angle \\(\\theta\\) . These parameters lead to a family of solutions , meaning the trajectory varies based on different values of \\(v_0\\) and \\(\\theta\\) . Key Observations Varying \\(v_0\\) changes speed and range . Varying \\(\\theta\\) affects trajectory shape , with the optimal angle for maximum range being \\(45^\\circ\\) . By adjusting \\(v_0\\) and \\(\\theta\\) , we can control the projectile's motion, optimizing for distance, height, or speed depending on the scenario. Practical applications It is important in sports such as basketball , discus and javelin to optimize angles for maximum range useful in aerospace and engineering Calculating Projectile Range at Different Angles Range Formula \\[\\begin{aligned} R &= \\text{range (meters)} \\\\ v_0 &= \\text{initial velocity (m/s)} \\\\ \\theta &= \\text{launch angle (degrees)} \\\\ g &= 9.81 \\text{ m/s}^2 \\text{ (acceleration due to gravity)} \\end{aligned}\\] Example 1 \\[ v_0 = 18 \\text{ m/s}, \\quad \\theta = 35^\\circ \\] \\[ R = \\frac{(18)^2 \\times \\sin(2 \\times 35^\\circ)}{9.81} \\] \\[ R = \\frac{324 \\times \\sin(70^\\circ)}{9.81} \\] \\[ R = \\frac{324 \\times 0.9397}{9.81} \\] \\[ R \\approx \\frac{304.5}{9.81} \\] \\[ R \\approx 31.0 \\text{ meters} \\] Example 2 \\[ v_0 = 22 \\text{ m/s}, \\quad \\theta = 50^\\circ \\] \\[ R = \\frac{(22)^2 \\times \\sin(2 \\times 50^\\circ)}{9.81} \\] \\[ R = \\frac{484 \\times \\sin(100^\\circ)}{9.81} \\] \\[ R = \\frac{484 \\times 0.9848}{9.81} \\] \\[ R \\approx \\frac{476.9}{9.81} \\] \\[ R \\approx 48.6 \\text{ meters} \\] For the same velocity, increasing the angle affects range differently. The maximum range occurs at 45 Higher velocity results in a longer range. Phython Script for plotting graph ```import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Gravity (m/s\u00b2) angles = np.linspace(0, 90, 100) # Angles from 0\u00b0 to 90\u00b0 # Initial velocities to compare velocities = [10, 20, 30] # m/s # Function to calculate range def calculate_range(v0, theta): return (v0**2 * np.sin(2 * np.radians(theta))) / g # Plot range vs. angle for different velocities plt.figure(figsize=(8, 5)) for v0 in velocities: ranges = calculate_range(v0, angles) plt.plot(angles, ranges, label=f\"$v_0$ = {v0} m/s\") # Graph Formatting plt.xlabel(\"Launch Angle (\u00b0)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Angle\") plt.legend() plt.grid(True) # Show the graph plt.show() Projectile Range vs. Angle Description The graph illustrates the relationship between the launch angle and the projectile range (m) for different initial velocities. The three curves represent: Blue Curve: $ v_0 $= 10 m/s Orange Curve: $ v_0 $= 20 m/s Green Curve: $ v_0 $ = 30 m/s Observations: The range increasess with angle up to 45\u00b0 , after which it decreases symmetrically. Higher initial velocity results in a greater range. The maximum range occurs at 45\u00b0 for all velocities. Key Equation: The projectile range R (ignoring air resistance) is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] where: - R = range - v = velocity - g = 9.81 m/s\u00b2 is the acceleration due to gravity. Limitations: No Air Resistance Considered \u2013 The graph assumes ideal projectile motion in a vacuum. No Wind Effects \u2013 External forces like wind resistance are ignored. No Spin or Magnus Effect \u2013 Rotational forces affecting range are not considered. Constant Acceleration Due to Gravity \u2013 Assumes a uniform gravitational field ( \\( g = 9.81 \\) m/s\u00b2).","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-simulation","text":"","title":"Projectile Motion Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-introduction","text":"","title":"1. Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#purpose-of-the-study","text":"In this report we will be studying the motion of a projectile. The goal of this study is to develop a clear mathematical model that describes how different factors, like the angle of launch and initial velocity, affect the range and trajectory of the projectile.","title":"Purpose of the Study"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-theoretical-foundation","text":"","title":"2. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-governing-equations-of-motion","text":"There are basic equations that govern the motion of a projectile. These equations describe the horizontal and vertical displacements over time, considering an initial velocity and launch angle.","title":"2.1 Governing Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-governing-equations-of-motion","text":"","title":"Derivation of Governing Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-horizontal-motion","text":"In projectile motion, the horizontal velocity remains constant (neglecting air resistance). The horizontal displacement is given by: \\[ x = v_0 \\cos(\\theta) t \\] where: - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the launch angle, - \\(t\\) is time.","title":"1. Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-vertical-motion","text":"The vertical motion is influenced by gravity, leading to the following equation: \\[ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] where: - \\(g\\) is the acceleration due to gravity. The velocity in the vertical direction changes over time: \\[ v_y = v_0 \\sin(\\theta) - g t \\] The time of flight, range, and maximum height can be derived from these equations.","title":"2. Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-family-of-solutions","text":"The trajectory of a projectile depends on two initial conditions: the initial velocity \\(v_0\\) and the launch angle \\(\\theta\\) . These parameters lead to a family of solutions , meaning the trajectory varies based on different values of \\(v_0\\) and \\(\\theta\\) .","title":"3. Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-observations","text":"Varying \\(v_0\\) changes speed and range . Varying \\(\\theta\\) affects trajectory shape , with the optimal angle for maximum range being \\(45^\\circ\\) . By adjusting \\(v_0\\) and \\(\\theta\\) , we can control the projectile's motion, optimizing for distance, height, or speed depending on the scenario.","title":"Key Observations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#practical-applications","text":"It is important in sports such as basketball , discus and javelin to optimize angles for maximum range useful in aerospace and engineering","title":"Practical applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#calculating-projectile-range-at-different-angles","text":"","title":"Calculating Projectile Range at Different Angles"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-formula","text":"\\[\\begin{aligned} R &= \\text{range (meters)} \\\\ v_0 &= \\text{initial velocity (m/s)} \\\\ \\theta &= \\text{launch angle (degrees)} \\\\ g &= 9.81 \\text{ m/s}^2 \\text{ (acceleration due to gravity)} \\end{aligned}\\]","title":"Range Formula"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#example-1","text":"\\[ v_0 = 18 \\text{ m/s}, \\quad \\theta = 35^\\circ \\] \\[ R = \\frac{(18)^2 \\times \\sin(2 \\times 35^\\circ)}{9.81} \\] \\[ R = \\frac{324 \\times \\sin(70^\\circ)}{9.81} \\] \\[ R = \\frac{324 \\times 0.9397}{9.81} \\] \\[ R \\approx \\frac{304.5}{9.81} \\] \\[ R \\approx 31.0 \\text{ meters} \\]","title":"Example 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#example-2","text":"\\[ v_0 = 22 \\text{ m/s}, \\quad \\theta = 50^\\circ \\] \\[ R = \\frac{(22)^2 \\times \\sin(2 \\times 50^\\circ)}{9.81} \\] \\[ R = \\frac{484 \\times \\sin(100^\\circ)}{9.81} \\] \\[ R = \\frac{484 \\times 0.9848}{9.81} \\] \\[ R \\approx \\frac{476.9}{9.81} \\] \\[ R \\approx 48.6 \\text{ meters} \\] For the same velocity, increasing the angle affects range differently. The maximum range occurs at 45 Higher velocity results in a longer range.","title":"Example 2"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#phython-script-for-plotting-graph","text":"```import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Gravity (m/s\u00b2) angles = np.linspace(0, 90, 100) # Angles from 0\u00b0 to 90\u00b0 # Initial velocities to compare velocities = [10, 20, 30] # m/s # Function to calculate range def calculate_range(v0, theta): return (v0**2 * np.sin(2 * np.radians(theta))) / g # Plot range vs. angle for different velocities plt.figure(figsize=(8, 5)) for v0 in velocities: ranges = calculate_range(v0, angles) plt.plot(angles, ranges, label=f\"$v_0$ = {v0} m/s\") # Graph Formatting plt.xlabel(\"Launch Angle (\u00b0)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Angle\") plt.legend() plt.grid(True) # Show the graph plt.show()","title":"Phython Script for plotting graph"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-range-vs-angle","text":"","title":"Projectile Range vs. Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#description","text":"The graph illustrates the relationship between the launch angle and the projectile range (m) for different initial velocities. The three curves represent: Blue Curve: $ v_0 $= 10 m/s Orange Curve: $ v_0 $= 20 m/s Green Curve: $ v_0 $ = 30 m/s","title":"Description"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#observations","text":"The range increasess with angle up to 45\u00b0 , after which it decreases symmetrically. Higher initial velocity results in a greater range. The maximum range occurs at 45\u00b0 for all velocities.","title":"Observations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-equation","text":"The projectile range R (ignoring air resistance) is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] where: - R = range - v = velocity - g = 9.81 m/s\u00b2 is the acceleration due to gravity.","title":"Key Equation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations","text":"No Air Resistance Considered \u2013 The graph assumes ideal projectile motion in a vacuum. No Wind Effects \u2013 External forces like wind resistance are ignored. No Spin or Magnus Effect \u2013 Rotational forces affecting range are not considered. Constant Acceleration Due to Gravity \u2013 Assumes a uniform gravitational field ( \\( g = 9.81 \\) m/s\u00b2).","title":"Limitations:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is an ideal system to study how damping, restoring forces, and external periodic forces interact. This system exhibits a rich variety of behaviors such as resonance, chaos, and periodic motion. These phenomena have widespread applications in fields like energy harvesting, mechanical structures under stress, and oscillating systems. By analyzing how external forces and damping affect the motion, we can gain insights into real-world systems like suspension bridges and oscillating circuits. 1. Theoretical Foundation Differential Equation for Forced Damped Pendulum The motion of a forced damped pendulum is described by the following differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + 2 \\gamma \\frac{d \\theta}{dt} + \\frac{g}{L} \\sin \\theta = F_0 \\cos(\\omega t) \\] Where: - \\( \\theta \\) is the angular displacement, - \\( \\gamma \\) is the damping coefficient, - \\( g \\) is the gravitational acceleration, - \\( L \\) is the length of the pendulum, - \\( F_0 \\) is the amplitude of the external driving force, - \\( \\omega \\) is the frequency of the external force. For small-angle approximations ( \\( \\theta \\) small), we can simplify \\( \\sin \\theta \\approx \\theta \\) , yielding: \\[ \\frac{d^2 \\theta}{dt^2} + 2 \\gamma \\frac{d \\theta}{dt} + \\frac{g}{L} \\theta = F_0 \\cos(\\omega t) \\] This is a second-order linear non-homogeneous ODE. Solution for Small-Angle Oscillations For small oscillations, the solution to this equation involves: - The homogeneous solution for damping and natural frequency, and - A particular solution for the external driving force. The general solution combines both, with resonance occurring when \\( \\omega \\approx \\omega_0 \\) , where \\( \\omega_0 = \\sqrt{\\frac{g}{L}} \\) . Resonance Conditions and Energy Implications At resonance ( \\( \\omega = \\omega_0 \\) ), the system absorbs energy efficiently from the external force, leading to large oscillations. Damping reduces the amplitude of oscillations at resonance, preventing them from growing indefinitely. 2. Analysis of Dynamics Influence of Damping, Driving Amplitude, and Frequency Damping Coefficient ( \\( \\gamma \\) ) : As \\( \\gamma \\) increases, the amplitude of oscillations decreases, and the system may move to a critically damped or overdamped state. Driving Amplitude ( \\( F_0 \\) ) : Increasing the driving amplitude increases the oscillation amplitude, especially near resonance. Driving Frequency ( \\( \\omega \\) ) : The frequency of the external force affects the system\u2019s oscillations. Resonance occurs when \\( \\omega \\) is close to \\( \\omega_0 \\) , causing large oscillations. 4. Implementation Computational Model Below is a Python script to simulate the motion of the forced damped pendulum: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of pendulum (m) gamma = 0.1 # damping coefficient F0 = 1.0 # amplitude of driving force omega = 1.0 # driving frequency theta_0 = 0.1 # initial angle (radians) omega_0 = np.sqrt(g / L) # natural frequency # Define the system of equations def pendulum(t, y): theta, omega_dot = y dydt = [omega_dot, -(2 * gamma * omega_dot + (g / L) * np.sin(theta)) + (F0 / L) * np.cos(omega * t)] return dydt # Time span and initial conditions t_span = (0, 100) y0 = [theta_0, 0] t_eval = np.linspace(*t_span, 10000) # Solve the system sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) # Plot the results plt.figure(figsize=(10, 6)) plt.plot(sol.t, sol.y[0], label='Angle (theta)') plt.title('Forced Damped Pendulum') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.legend() plt.grid(True) plt.show() 4.1 Effect of Parameters Damping ( \\( \\gamma \\) ) : Higher damping suppresses oscillations. Driving Amplitude ( \\( A \\) ) : Large \\( A \\) can lead to chaotic behavior. Driving Frequency ( \\( \\omega \\) ) : When \\( \\omega \\approx \\omega_0 \\) , resonance occurs, leading to large oscillations. 4.2 Transition to Chaos By varying \\( A \\) and \\( \\omega \\) , the pendulum can exhibit periodic, quasiperiodic, or chaotic motion.Phase space plots and Poincar\u00e9 sections illustrate these behaviors. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint def pendulum_equations(y, t, gamma, omega0, A, omega): theta, v = y dydt = [v, -gamma * v - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] return dydt # Parameters gamma = 0.5 # Damping coefficient omega0 = 1.5 # Natural frequency A = 1.2 # Driving force amplitude omega = 2.0 # Driving frequency # Initial conditions y0 = [0.1, 0] # Initial angle and velocity t = np.linspace(0, 50, 1000) # Time array # Solve ODE y = odeint(pendulum_equations, y0, t, args=(gamma, omega0, A, omega)) # Plot results plt.figure(figsize=(10, 5)) plt.plot(y[:, 0], y[:, 1], label='Phase Space') plt.xlabel('Theta (angle)') plt.ylabel('Angular velocity') plt.title('Phase Portrait of Forced Damped Pendulum') plt.legend() plt.grid() plt.show() Poincare System import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint def pendulum_equations(y, t, gamma, omega0, A, omega): theta, v = y dydt = [v, -gamma * v - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] return dydt # Parameters gamma = 0.5 # Damping coefficient omega0 = 1.5 # Natural frequency A = 1.2 # Driving force amplitude omega = 2.0 # Driving frequency # Initial conditions y0 = [0.1, 0] # Initial angle and velocity t = np.linspace(0, 50, 1000) # Time array # Solve ODE y = odeint(pendulum_equations, y0, t, args=(gamma, omega0, A, omega)) # Plot results poincare_times = np.arange(0, 50, np.pi / omega) # Stroboscopic points theta_poincare = y[np.searchsorted(t, poincare_times), 0] plt.figure(figsize=(8, 5)) plt.scatter(poincare_times, theta_poincare, s=5, color='red') plt.xlabel('Time') plt.ylabel('Theta (angle)') plt.title('Poincar\u00e9 Section of Forced Damped Pendulum') plt.grid() plt.show() 5. Practical Applications Energy Harvesting : Utilizing resonance for efficient energy transfer. Suspension Bridges : Preventing dangerous oscillations. Electrical Circuits : Analogous behavior in driven RLC circuits. 6. Conclusion The forced damped pendulum is a rich system for studying nonlinear dynamics. Through numerical simulations, we can observe diverse behaviors, from simple oscillations to chaos, providing insight into both fundamental physics and engineering applications.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is an ideal system to study how damping, restoring forces, and external periodic forces interact. This system exhibits a rich variety of behaviors such as resonance, chaos, and periodic motion. These phenomena have widespread applications in fields like energy harvesting, mechanical structures under stress, and oscillating systems. By analyzing how external forces and damping affect the motion, we can gain insights into real-world systems like suspension bridges and oscillating circuits.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#differential-equation-for-forced-damped-pendulum","text":"The motion of a forced damped pendulum is described by the following differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + 2 \\gamma \\frac{d \\theta}{dt} + \\frac{g}{L} \\sin \\theta = F_0 \\cos(\\omega t) \\] Where: - \\( \\theta \\) is the angular displacement, - \\( \\gamma \\) is the damping coefficient, - \\( g \\) is the gravitational acceleration, - \\( L \\) is the length of the pendulum, - \\( F_0 \\) is the amplitude of the external driving force, - \\( \\omega \\) is the frequency of the external force. For small-angle approximations ( \\( \\theta \\) small), we can simplify \\( \\sin \\theta \\approx \\theta \\) , yielding: \\[ \\frac{d^2 \\theta}{dt^2} + 2 \\gamma \\frac{d \\theta}{dt} + \\frac{g}{L} \\theta = F_0 \\cos(\\omega t) \\] This is a second-order linear non-homogeneous ODE.","title":"Differential Equation for Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#solution-for-small-angle-oscillations","text":"For small oscillations, the solution to this equation involves: - The homogeneous solution for damping and natural frequency, and - A particular solution for the external driving force. The general solution combines both, with resonance occurring when \\( \\omega \\approx \\omega_0 \\) , where \\( \\omega_0 = \\sqrt{\\frac{g}{L}} \\) .","title":"Solution for Small-Angle Oscillations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions-and-energy-implications","text":"At resonance ( \\( \\omega = \\omega_0 \\) ), the system absorbs energy efficiently from the external force, leading to large oscillations. Damping reduces the amplitude of oscillations at resonance, preventing them from growing indefinitely.","title":"Resonance Conditions and Energy Implications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#influence-of-damping-driving-amplitude-and-frequency","text":"Damping Coefficient ( \\( \\gamma \\) ) : As \\( \\gamma \\) increases, the amplitude of oscillations decreases, and the system may move to a critically damped or overdamped state. Driving Amplitude ( \\( F_0 \\) ) : Increasing the driving amplitude increases the oscillation amplitude, especially near resonance. Driving Frequency ( \\( \\omega \\) ) : The frequency of the external force affects the system\u2019s oscillations. Resonance occurs when \\( \\omega \\) is close to \\( \\omega_0 \\) , causing large oscillations.","title":"Influence of Damping, Driving Amplitude, and Frequency"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#computational-model","text":"Below is a Python script to simulate the motion of the forced damped pendulum: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of pendulum (m) gamma = 0.1 # damping coefficient F0 = 1.0 # amplitude of driving force omega = 1.0 # driving frequency theta_0 = 0.1 # initial angle (radians) omega_0 = np.sqrt(g / L) # natural frequency # Define the system of equations def pendulum(t, y): theta, omega_dot = y dydt = [omega_dot, -(2 * gamma * omega_dot + (g / L) * np.sin(theta)) + (F0 / L) * np.cos(omega * t)] return dydt # Time span and initial conditions t_span = (0, 100) y0 = [theta_0, 0] t_eval = np.linspace(*t_span, 10000) # Solve the system sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) # Plot the results plt.figure(figsize=(10, 6)) plt.plot(sol.t, sol.y[0], label='Angle (theta)') plt.title('Forced Damped Pendulum') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.legend() plt.grid(True) plt.show()","title":"Computational Model"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#41-effect-of-parameters","text":"Damping ( \\( \\gamma \\) ) : Higher damping suppresses oscillations. Driving Amplitude ( \\( A \\) ) : Large \\( A \\) can lead to chaotic behavior. Driving Frequency ( \\( \\omega \\) ) : When \\( \\omega \\approx \\omega_0 \\) , resonance occurs, leading to large oscillations.","title":"4.1 Effect of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#42-transition-to-chaos","text":"By varying \\( A \\) and \\( \\omega \\) , the pendulum can exhibit periodic, quasiperiodic, or chaotic motion.Phase space plots and Poincar\u00e9 sections illustrate these behaviors. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint def pendulum_equations(y, t, gamma, omega0, A, omega): theta, v = y dydt = [v, -gamma * v - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] return dydt # Parameters gamma = 0.5 # Damping coefficient omega0 = 1.5 # Natural frequency A = 1.2 # Driving force amplitude omega = 2.0 # Driving frequency # Initial conditions y0 = [0.1, 0] # Initial angle and velocity t = np.linspace(0, 50, 1000) # Time array # Solve ODE y = odeint(pendulum_equations, y0, t, args=(gamma, omega0, A, omega)) # Plot results plt.figure(figsize=(10, 5)) plt.plot(y[:, 0], y[:, 1], label='Phase Space') plt.xlabel('Theta (angle)') plt.ylabel('Angular velocity') plt.title('Phase Portrait of Forced Damped Pendulum') plt.legend() plt.grid() plt.show()","title":"4.2 Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#poincare-system","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint def pendulum_equations(y, t, gamma, omega0, A, omega): theta, v = y dydt = [v, -gamma * v - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] return dydt # Parameters gamma = 0.5 # Damping coefficient omega0 = 1.5 # Natural frequency A = 1.2 # Driving force amplitude omega = 2.0 # Driving frequency # Initial conditions y0 = [0.1, 0] # Initial angle and velocity t = np.linspace(0, 50, 1000) # Time array # Solve ODE y = odeint(pendulum_equations, y0, t, args=(gamma, omega0, A, omega)) # Plot results poincare_times = np.arange(0, 50, np.pi / omega) # Stroboscopic points theta_poincare = y[np.searchsorted(t, poincare_times), 0] plt.figure(figsize=(8, 5)) plt.scatter(poincare_times, theta_poincare, s=5, color='red') plt.xlabel('Time') plt.ylabel('Theta (angle)') plt.title('Poincar\u00e9 Section of Forced Damped Pendulum') plt.grid() plt.show()","title":"Poincare System"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-practical-applications","text":"Energy Harvesting : Utilizing resonance for efficient energy transfer. Suspension Bridges : Preventing dangerous oscillations. Electrical Circuits : Analogous behavior in driven RLC circuits.","title":"5. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-conclusion","text":"The forced damped pendulum is a rich system for studying nonlinear dynamics. Through numerical simulations, we can observe diverse behaviors, from simple oscillations to chaos, providing insight into both fundamental physics and engineering applications.","title":"6. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation Kepler's Third Law, which relates the square of the orbital period to the cube of the orbital radius, is a cornerstone of celestial mechanics. This relationship provides insight into the motion of celestial bodies and the nature of gravitational interactions. It is used to predict planetary movements, the behavior of satellites, and even the distances to distant stars. By analyzing this law, we can connect fundamental principles of gravity with real-world phenomena like planetary orbits and satellite systems. 1. Derivation of the Relationship Gravitational Force and Circular Motion The gravitational force provides the necessary centripetal force for a planet to maintain a circular orbit around the Sun. The gravitational force \\( F \\) between two objects is given by Newton's Law of Gravitation: \\[ F = \\frac{G M m}{r^2} \\] Where: - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body (e.g., the Sun), - \\( m \\) is the mass of the orbiting object (e.g., a planet), - \\( r \\) is the distance between the two objects. For a circular orbit, the centripetal force is: \\[ F = \\frac{m v^2}{r} \\] Where \\( v \\) is the orbital velocity of the planet. Equating the gravitational force and the centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplifying, we get: \\[ v^2 = \\frac{G M}{r} \\] Orbital Period The orbital velocity \\( v \\) is related to the orbital period \\( T \\) by the circumference of the orbit \\( 2 \\pi r \\) : \\[ v = \\frac{2 \\pi r}{T} \\] Substituting this into the previous equation: \\[ \\left( \\frac{2 \\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] Simplifying further: \\[ \\frac{4 \\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Rearranging, we obtain Kepler\u2019s Third Law: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] This shows that the square of the orbital period \\( T \\) is directly proportional to the cube of the orbital radius \\( r \\) , with a constant of proportionality involving the mass of the central body \\( M \\) . 2. Implications for Astronomy Planetary Masses and Distances Kepler\u2019s Third Law can be used to calculate the masses of celestial bodies (such as planets and stars) if the orbital period and radius are known. For example, by observing the Moon's orbit around Earth, we can estimate the mass of the Earth, or using the orbital parameters of planets, we can determine the mass of the Sun. Satellite Orbits For artificial satellites orbiting Earth, the relationship allows for the determination of the orbital period for a given orbital radius. This is crucial for understanding satellite motion and predicting satellite trajectories. Practical Use in Space Exploration This law is instrumental for mission planning and navigation in space, such as calculating the timing for satellite launches or space probes. 3. Real-World Examples The Moon's Orbit around Earth The Moon\u2019s orbit around Earth provides an example of Kepler\u2019s Third Law in action. By knowing the radius of the Moon\u2019s orbit and the period, we can apply Kepler\u2019s Third Law to calculate the mass of Earth, which is consistent with known values. Planetary Orbits in the Solar System In the Solar System, planets follow nearly circular orbits around the Sun. By measuring the orbital period and radius of a planet, Kepler's Third Law can be used to derive the mass of the Sun. This relationship also helps us understand the spacing of the planets and how they interact gravitationally. 4. Computational Model Simulating Circular Orbits import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) # Orbital radius and period of the Moon r_moon = 3.844e8 # Orbital radius of the Moon (meters) T_moon = 27.3 * 24 * 3600 # Orbital period of the Moon (seconds) # Range of orbital radii for calculation (from 1,000 km to 1,000,000 km) radii = np.linspace(1e6, 1e9, 500) # in meters # Calculate orbital periods using Kepler's Third Law: T^2 = (4 * pi^2 * r^3) / (G * M) periods = 2 * np.pi * np.sqrt(radii**3 / (G * M_earth)) # Convert period from seconds to days periods_days = periods / (60 * 60 * 24) # Plot Orbital Period vs Orbital Radius for the Earth-Moon system plt.figure(figsize=(8, 6)) plt.plot(radii / 1e6, periods_days, label='Orbital Period', color='b') plt.xlabel('Orbital Radius (million meters)') plt.ylabel('Orbital Period (days)') plt.title('Orbital Period vs Orbital Radius (Earth-Moon System)') plt.grid(True) plt.legend() plt.show() import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Orbital radii of the first five planets in AU planet_names = ['Me', 'Ve', 'Ea', 'Ma', 'Ju'] # First two letters of each planet name radii_au = np.array([0.387, 0.723, 1.000, 1.524, 5.203]) # in AU # Convert AU to meters radii_m = radii_au * 1.496e11 # Convert AU to meters # Calculate the orbital periods using Kepler's Third Law periods_seconds = 2 * np.pi * np.sqrt(radii_m**3 / (G * M_sun)) # Convert period from seconds to Earth years periods_years = periods_seconds / (60 * 60 * 24 * 365.25) # Plot the graph: Orbital Period vs Orbital Radius plt.figure(figsize=(10, 6)) plt.plot(radii_au, periods_years, marker='o', linestyle='-', color='b', label='Orbital Period') # Add labels to each point with adjusted positions for i, planet in enumerate(planet_names): plt.text(radii_au[i], periods_years[i], planet, fontsize=9, ha='center', va='bottom', color='blue') # Labeling and displaying the plot plt.xlabel('$r^3$', fontsize=12) # Changed label here plt.ylabel('$T^2$', fontsize=12) # Changed label here plt.title('Orbital Period vs Orbital Radius for the First Five Planets', fontsize=14) # Adjust the x and y axis limits for better fit plt.xlim(0, 5.5) plt.ylim(0, 15) plt.grid(True) plt.xticks(np.arange(0, 6, 0.5)) plt.yticks(np.arange(0, 16, 1)) plt.legend() plt.show()","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler's Third Law, which relates the square of the orbital period to the cube of the orbital radius, is a cornerstone of celestial mechanics. This relationship provides insight into the motion of celestial bodies and the nature of gravitational interactions. It is used to predict planetary movements, the behavior of satellites, and even the distances to distant stars. By analyzing this law, we can connect fundamental principles of gravity with real-world phenomena like planetary orbits and satellite systems.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-derivation-of-the-relationship","text":"","title":"1. Derivation of the Relationship"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravitational-force-and-circular-motion","text":"The gravitational force provides the necessary centripetal force for a planet to maintain a circular orbit around the Sun. The gravitational force \\( F \\) between two objects is given by Newton's Law of Gravitation: \\[ F = \\frac{G M m}{r^2} \\] Where: - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body (e.g., the Sun), - \\( m \\) is the mass of the orbiting object (e.g., a planet), - \\( r \\) is the distance between the two objects. For a circular orbit, the centripetal force is: \\[ F = \\frac{m v^2}{r} \\] Where \\( v \\) is the orbital velocity of the planet. Equating the gravitational force and the centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplifying, we get: \\[ v^2 = \\frac{G M}{r} \\]","title":"Gravitational Force and Circular Motion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period","text":"The orbital velocity \\( v \\) is related to the orbital period \\( T \\) by the circumference of the orbit \\( 2 \\pi r \\) : \\[ v = \\frac{2 \\pi r}{T} \\] Substituting this into the previous equation: \\[ \\left( \\frac{2 \\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] Simplifying further: \\[ \\frac{4 \\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Rearranging, we obtain Kepler\u2019s Third Law: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] This shows that the square of the orbital period \\( T \\) is directly proportional to the cube of the orbital radius \\( r \\) , with a constant of proportionality involving the mass of the central body \\( M \\) .","title":"Orbital Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-for-astronomy","text":"","title":"2. Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#planetary-masses-and-distances","text":"Kepler\u2019s Third Law can be used to calculate the masses of celestial bodies (such as planets and stars) if the orbital period and radius are known. For example, by observing the Moon's orbit around Earth, we can estimate the mass of the Earth, or using the orbital parameters of planets, we can determine the mass of the Sun.","title":"Planetary Masses and Distances"},{"location":"1%20Physics/2%20Gravity/Problem_1/#satellite-orbits","text":"For artificial satellites orbiting Earth, the relationship allows for the determination of the orbital period for a given orbital radius. This is crucial for understanding satellite motion and predicting satellite trajectories.","title":"Satellite Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#practical-use-in-space-exploration","text":"This law is instrumental for mission planning and navigation in space, such as calculating the timing for satellite launches or space probes.","title":"Practical Use in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"","title":"3. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#the-moons-orbit-around-earth","text":"The Moon\u2019s orbit around Earth provides an example of Kepler\u2019s Third Law in action. By knowing the radius of the Moon\u2019s orbit and the period, we can apply Kepler\u2019s Third Law to calculate the mass of Earth, which is consistent with known values.","title":"The Moon's Orbit around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#planetary-orbits-in-the-solar-system","text":"In the Solar System, planets follow nearly circular orbits around the Sun. By measuring the orbital period and radius of a planet, Kepler's Third Law can be used to derive the mass of the Sun. This relationship also helps us understand the spacing of the planets and how they interact gravitationally.","title":"Planetary Orbits in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-computational-model","text":"","title":"4. Computational Model"},{"location":"1%20Physics/2%20Gravity/Problem_1/#simulating-circular-orbits","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) # Orbital radius and period of the Moon r_moon = 3.844e8 # Orbital radius of the Moon (meters) T_moon = 27.3 * 24 * 3600 # Orbital period of the Moon (seconds) # Range of orbital radii for calculation (from 1,000 km to 1,000,000 km) radii = np.linspace(1e6, 1e9, 500) # in meters # Calculate orbital periods using Kepler's Third Law: T^2 = (4 * pi^2 * r^3) / (G * M) periods = 2 * np.pi * np.sqrt(radii**3 / (G * M_earth)) # Convert period from seconds to days periods_days = periods / (60 * 60 * 24) # Plot Orbital Period vs Orbital Radius for the Earth-Moon system plt.figure(figsize=(8, 6)) plt.plot(radii / 1e6, periods_days, label='Orbital Period', color='b') plt.xlabel('Orbital Radius (million meters)') plt.ylabel('Orbital Period (days)') plt.title('Orbital Period vs Orbital Radius (Earth-Moon System)') plt.grid(True) plt.legend() plt.show() import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Orbital radii of the first five planets in AU planet_names = ['Me', 'Ve', 'Ea', 'Ma', 'Ju'] # First two letters of each planet name radii_au = np.array([0.387, 0.723, 1.000, 1.524, 5.203]) # in AU # Convert AU to meters radii_m = radii_au * 1.496e11 # Convert AU to meters # Calculate the orbital periods using Kepler's Third Law periods_seconds = 2 * np.pi * np.sqrt(radii_m**3 / (G * M_sun)) # Convert period from seconds to Earth years periods_years = periods_seconds / (60 * 60 * 24 * 365.25) # Plot the graph: Orbital Period vs Orbital Radius plt.figure(figsize=(10, 6)) plt.plot(radii_au, periods_years, marker='o', linestyle='-', color='b', label='Orbital Period') # Add labels to each point with adjusted positions for i, planet in enumerate(planet_names): plt.text(radii_au[i], periods_years[i], planet, fontsize=9, ha='center', va='bottom', color='blue') # Labeling and displaying the plot plt.xlabel('$r^3$', fontsize=12) # Changed label here plt.ylabel('$T^2$', fontsize=12) # Changed label here plt.title('Orbital Period vs Orbital Radius for the First Five Planets', fontsize=14) # Adjust the x and y axis limits for better fit plt.xlim(0, 5.5) plt.ylim(0, 15) plt.grid(True) plt.xticks(np.arange(0, 6, 0.5)) plt.yticks(np.arange(0, 16, 1)) plt.legend() plt.show()","title":"Simulating Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 \ud83c\udf0c Trajectories of a Freely Released Payload Near Earth \ud83d\udef8 Introduction When a payload is released from a high-speed spacecraft orbiting Earth, its subsequent trajectory is determined by a combination of initial velocity, position, and gravitational forces exerted by Earth. Understanding the various potential trajectories \u2014 such as elliptical orbits, escape trajectories, and free fall \u2014 is critical for mission planning, including satellite deployment, planetary exploration, or payload reentry. This problem explores the impact of different initial velocities and release points on the trajectory of a freely released payload near Earth, leveraging Newton's laws of motion and gravitational forces. The mathematical treatment of this problem aids in mission planning for space exploration, satellite deployment, and re-entry trajectories. \ud83d\udcda Theoretical Background The motion of a freely released payload near Earth is governed by Newton's Law of Universal Gravitation , which gives the gravitational force \\( F \\) between two masses \\( m_1 \\) (the payload) and \\( m_2 \\) (the Earth) as: \\[ F = G \\frac{m_1 m_2}{r^2} \\] Where: \\( F \\) is the gravitational force between the two objects, \\( G = 6.674 \\times 10^{-11} \\, \\text{Nm}^2\\text{kg}^{-2} \\) is the gravitational constant, \\( m_1 \\) and \\( m_2 \\) are the masses of the objects (in this case, the payload and Earth), \\( r \\) is the distance between the center of Earth and the payload. The gravitational force causes the payload to accelerate towards Earth, following a trajectory determined by the initial conditions of velocity and position. The motion can be described by the following differential equation derived from Newton\u2019s Second Law of Motion: \\[ m_1 \\frac{d^2 \\vec{r}}{dt^2} = -G \\frac{m_1 m_2}{r^2} \\hat{r} \\] Where: \\( \\vec{r} \\) is the position vector of the payload relative to Earth, \\( \\hat{r} \\) is the unit vector in the direction of the position vector, \\( m_1 \\) and \\( m_2 \\) are the masses of the payload and Earth, respectively, \\( r \\) is the distance from the Earth's center. \ud83d\udd2d Types of Trajectories Parabolic Trajectory : A parabolic trajectory occurs when the object has just enough velocity to escape Earth's gravitational field but not enough to continue moving indefinitely. The velocity needed for a parabolic trajectory is the escape velocity . The escape velocity \\( v_{\\text{esc}} \\) is given by: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM_{\\text{Earth}}}{r}} \\] Elliptical Trajectory : An elliptical trajectory is when the object is bound to Earth's gravity but will orbit in an elliptical path. The energy of the system is negative, meaning the object will eventually return to Earth. The velocity of the object at any point in its orbit can be found using the vis-viva equation : \\[ v(r) = \\sqrt{GM_{\\text{Earth}} \\left( \\frac{2}{r} - \\frac{1}{a} \\right)} \\] Where: - \\( r \\) is the current distance of the object from Earth, - \\( a \\) is the semi-major axis of the orbit. Hyperbolic Trajectory : A hyperbolic trajectory occurs when the object has enough velocity to escape Earth's gravitational field and continues moving away indefinitely. The total energy of the system is positive, and the velocity at any point is given by: \\[ v(r) = \\sqrt{GM_{\\text{Earth}} \\left( \\frac{2}{r} - \\frac{1}{a} \\right)} \\] Where \\( a \\) is the semi-major axis (negative for hyperbolic trajectories). \u2699\ufe0f Numerical Method: Runge-Kutta Integration To simulate the trajectory of a freely released payload, we will numerically integrate the equations of motion using the Runge-Kutta method , which is a fourth-order method providing more accurate solutions than the Euler method. The method involves: Computing intermediate values for position and velocity, Using these intermediate steps to update the position and velocity at each time step. \ud83d\udee0\ufe0f Python Implementation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (Nm^2/kg^2) M_earth = 5.972e24 # Mass of Earth (kg) r_earth = 6.371e6 # Radius of Earth (m) # Initial conditions initial_position = np.array([7000e3, 0]) # Initial position (7000 km from Earth's center) initial_velocity = np.array([0, 7.12e3]) # Initial velocity (7.12 km/s tangential velocity) # Time setup t0 = 0 # Initial time tf = 6000 # Final time (seconds) dt = 10 # Time step (seconds) time_points = np.arange(t0, tf, dt) # Runge-Kutta integration method def acceleration(position): r = np.linalg.norm(position) return -G * M_earth * position / r**3 def runge_kutta(position, velocity, dt): k1v = acceleration(position) k1p = velocity k2v = acceleration(position + 0.5 * dt * k1p) k2p = velocity + 0.5 * dt * k1v k3v = acceleration(position + 0.5 * dt * k2p) k3p = velocity + 0.5 * dt * k2v k4v = acceleration(position + dt * k3p) k4p = velocity + dt * k3v new_position = position + (dt / 6) * (k1p + 2*k2p + 2*k3p + k4p) new_velocity = velocity + (dt / 6) * (k1v + 2*k2v + 2*k3v + k4v) return new_position, new_velocity # Initial conditions position = initial_position velocity = initial_velocity # Lists for storing the results positions = [] velocities = [] # Run the simulation for t in time_points: positions.append(position) velocities.append(velocity) position, velocity = runge_kutta(position, velocity, dt) # Convert the positions to numpy arrays for plotting positions = np.array(positions) # Plot the trajectory plt.figure(figsize=(8, 8)) plt.plot(positions[:, 0] / 1e3, positions[:, 1] / 1e3, label=\"Payload Trajectory\") plt.scatter(0, 0, color='red', label=\"Earth\", s=100) plt.title(\"Trajectory of Freely Released Payload Near Earth\") plt.xlabel(\"X Position (km)\") plt.ylabel(\"Y Position (km)\") plt.grid(True) plt.legend() plt.axis('equal') plt.show() Parabolic Trajectory: This plot will show the path of an object with escape velocity from Earth, which will travel outward and return. Elliptical Trajectory: The object follows an elliptical orbit, returning to Earth. Hyperbolic Trajectory: The object escapes Earth's gravitational field, following a hyperbolic path outwards indefinitely. Each graph will also include a yellow dot representing Earth at the origin (0, 0) and will display the trajectory path of the object. The axis('equal') ensures that the axes have the same scaling for accurate representation of the orbital shape. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (Nm^2/kg^2) M_earth = 5.972e24 # Mass of Earth (kg) r_earth = 6.371e6 # Radius of Earth (m) # Initial conditions for each type of trajectory: # 1. Parabolic: Exact escape velocity (7.12 km/s) # 2. Elliptical: A velocity less than escape velocity # 3. Hyperbolic: A velocity greater than escape velocity # Time setup t0 = 0 # Initial time tf = 6000 # Final time (seconds) dt = 10 # Time step (seconds) time_points = np.arange(t0, tf, dt) # Acceleration due to gravity (Newton's Law) def acceleration(position): r = np.linalg.norm(position) return -G * M_earth * position / r**3 # Runge-Kutta method def runge_kutta(position, velocity, dt): k1v = acceleration(position) k1p = velocity k2v = acceleration(position + 0.5 * dt * k1p) k2p = velocity + 0.5 * dt * k1v k3v = acceleration(position + 0.5 * dt * k2p) k3p = velocity + 0.5 * dt * k2v k4v = acceleration(position + dt * k3p) k4p = velocity + dt * k3v new_position = position + (dt / 6) * (k1p + 2*k2p + 2*k3p + k4p) new_velocity = velocity + (dt / 6) * (k1v + 2*k2v + 2*k3v + k4v) return new_position, new_velocity # Define initial conditions for the different types of trajectories # Parabolic trajectory (escape velocity, 7.12 km/s tangential) initial_position_parabolic = np.array([7000e3, 0]) # 7000 km from Earth's center initial_velocity_parabolic = np.array([0, 7.12e3]) # Parabolic velocity (7.12 km/s tangential) # Elliptical trajectory (velocity less than escape velocity, 5 km/s) initial_position_elliptical = np.array([7000e3, 0]) # 7000 km from Earth's center initial_velocity_elliptical = np.array([0, 5e3]) # Elliptical velocity (5 km/s tangential) # Hyperbolic trajectory (velocity greater than escape velocity, 10 km/s) initial_position_hyperbolic = np.array([7000e3, 0]) # 7000 km from Earth's center initial_velocity_hyperbolic = np.array([0, 10e3]) # Hyperbolic velocity (10 km/s tangential) # List to store results for each trajectory type positions_parabolic = [] positions_elliptical = [] positions_hyperbolic = [] # Run simulations for each trajectory def simulate_trajectory(initial_position, initial_velocity): position = initial_position velocity = initial_velocity positions = [] for t in time_points: positions.append(position) position, velocity = runge_kutta(position, velocity, dt) return np.array(positions) # Simulate all three types of trajectories positions_parabolic = simulate_trajectory(initial_position_parabolic, initial_velocity_parabolic) positions_elliptical = simulate_trajectory(initial_position_elliptical, initial_velocity_elliptical) positions_hyperbolic = simulate_trajectory(initial_position_hyperbolic, initial_velocity_hyperbolic) # Plot the results for Parabolic trajectory plt.figure(figsize=(8, 6)) plt.plot(positions_parabolic[:, 0] / 1e3, positions_parabolic[:, 1] / 1e3, label=\"Parabolic Trajectory (Escape Velocity)\", color='blue') plt.scatter(0, 0, color='yellow', label=\"Earth\", s=100) plt.title(\"Parabolic Trajectory (Escape Velocity)\") plt.xlabel(\"X Position (km)\") plt.ylabel(\"Y Position (km)\") plt.grid(True) plt.legend() plt.axis('equal') plt.show() # Plot the results for Elliptical trajectory plt.figure(figsize=(8, 6)) plt.plot(positions_elliptical[:, 0] / 1e3, positions_elliptical[:, 1] / 1e3, label=\"Elliptical Trajectory (Sub-Escape Velocity)\", color='green') plt.scatter(0, 0, color='yellow', label=\"Earth\", s=100) plt.title(\"Elliptical Trajectory (Sub-Escape Velocity)\") plt.xlabel(\"X Position (km)\") plt.ylabel(\"Y Position (km)\") plt.grid(True) plt.legend() plt.axis('equal') plt.show() # Plot the results for Hyperbolic trajectory plt.figure(figsize=(8, 6)) plt.plot(positions_hyperbolic[:, 0] / 1e3, positions_hyperbolic[:, 1] / 1e3, label=\"Hyperbolic Trajectory (Super-Escape Velocity)\", color='red') plt.scatter(0, 0, color='yellow', label=\"Earth\", s=100) plt.title(\"Hyperbolic Trajectory (Super-Escape Velocity)\") plt.xlabel(\"X Position (km)\") plt.ylabel(\"Y Position (km)\") plt.grid(True) plt.legend() plt.axis('equal') plt.show()","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"\ud83c\udf0c Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#introduction","text":"When a payload is released from a high-speed spacecraft orbiting Earth, its subsequent trajectory is determined by a combination of initial velocity, position, and gravitational forces exerted by Earth. Understanding the various potential trajectories \u2014 such as elliptical orbits, escape trajectories, and free fall \u2014 is critical for mission planning, including satellite deployment, planetary exploration, or payload reentry. This problem explores the impact of different initial velocities and release points on the trajectory of a freely released payload near Earth, leveraging Newton's laws of motion and gravitational forces. The mathematical treatment of this problem aids in mission planning for space exploration, satellite deployment, and re-entry trajectories.","title":"\ud83d\udef8 Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-background","text":"The motion of a freely released payload near Earth is governed by Newton's Law of Universal Gravitation , which gives the gravitational force \\( F \\) between two masses \\( m_1 \\) (the payload) and \\( m_2 \\) (the Earth) as: \\[ F = G \\frac{m_1 m_2}{r^2} \\] Where: \\( F \\) is the gravitational force between the two objects, \\( G = 6.674 \\times 10^{-11} \\, \\text{Nm}^2\\text{kg}^{-2} \\) is the gravitational constant, \\( m_1 \\) and \\( m_2 \\) are the masses of the objects (in this case, the payload and Earth), \\( r \\) is the distance between the center of Earth and the payload. The gravitational force causes the payload to accelerate towards Earth, following a trajectory determined by the initial conditions of velocity and position. The motion can be described by the following differential equation derived from Newton\u2019s Second Law of Motion: \\[ m_1 \\frac{d^2 \\vec{r}}{dt^2} = -G \\frac{m_1 m_2}{r^2} \\hat{r} \\] Where: \\( \\vec{r} \\) is the position vector of the payload relative to Earth, \\( \\hat{r} \\) is the unit vector in the direction of the position vector, \\( m_1 \\) and \\( m_2 \\) are the masses of the payload and Earth, respectively, \\( r \\) is the distance from the Earth's center.","title":"\ud83d\udcda Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"Parabolic Trajectory : A parabolic trajectory occurs when the object has just enough velocity to escape Earth's gravitational field but not enough to continue moving indefinitely. The velocity needed for a parabolic trajectory is the escape velocity . The escape velocity \\( v_{\\text{esc}} \\) is given by: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM_{\\text{Earth}}}{r}} \\] Elliptical Trajectory : An elliptical trajectory is when the object is bound to Earth's gravity but will orbit in an elliptical path. The energy of the system is negative, meaning the object will eventually return to Earth. The velocity of the object at any point in its orbit can be found using the vis-viva equation : \\[ v(r) = \\sqrt{GM_{\\text{Earth}} \\left( \\frac{2}{r} - \\frac{1}{a} \\right)} \\] Where: - \\( r \\) is the current distance of the object from Earth, - \\( a \\) is the semi-major axis of the orbit. Hyperbolic Trajectory : A hyperbolic trajectory occurs when the object has enough velocity to escape Earth's gravitational field and continues moving away indefinitely. The total energy of the system is positive, and the velocity at any point is given by: \\[ v(r) = \\sqrt{GM_{\\text{Earth}} \\left( \\frac{2}{r} - \\frac{1}{a} \\right)} \\] Where \\( a \\) is the semi-major axis (negative for hyperbolic trajectories).","title":"\ud83d\udd2d Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-method-runge-kutta-integration","text":"To simulate the trajectory of a freely released payload, we will numerically integrate the equations of motion using the Runge-Kutta method , which is a fourth-order method providing more accurate solutions than the Euler method. The method involves: Computing intermediate values for position and velocity, Using these intermediate steps to update the position and velocity at each time step.","title":"\u2699\ufe0f Numerical Method: Runge-Kutta Integration"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (Nm^2/kg^2) M_earth = 5.972e24 # Mass of Earth (kg) r_earth = 6.371e6 # Radius of Earth (m) # Initial conditions initial_position = np.array([7000e3, 0]) # Initial position (7000 km from Earth's center) initial_velocity = np.array([0, 7.12e3]) # Initial velocity (7.12 km/s tangential velocity) # Time setup t0 = 0 # Initial time tf = 6000 # Final time (seconds) dt = 10 # Time step (seconds) time_points = np.arange(t0, tf, dt) # Runge-Kutta integration method def acceleration(position): r = np.linalg.norm(position) return -G * M_earth * position / r**3 def runge_kutta(position, velocity, dt): k1v = acceleration(position) k1p = velocity k2v = acceleration(position + 0.5 * dt * k1p) k2p = velocity + 0.5 * dt * k1v k3v = acceleration(position + 0.5 * dt * k2p) k3p = velocity + 0.5 * dt * k2v k4v = acceleration(position + dt * k3p) k4p = velocity + dt * k3v new_position = position + (dt / 6) * (k1p + 2*k2p + 2*k3p + k4p) new_velocity = velocity + (dt / 6) * (k1v + 2*k2v + 2*k3v + k4v) return new_position, new_velocity # Initial conditions position = initial_position velocity = initial_velocity # Lists for storing the results positions = [] velocities = [] # Run the simulation for t in time_points: positions.append(position) velocities.append(velocity) position, velocity = runge_kutta(position, velocity, dt) # Convert the positions to numpy arrays for plotting positions = np.array(positions) # Plot the trajectory plt.figure(figsize=(8, 8)) plt.plot(positions[:, 0] / 1e3, positions[:, 1] / 1e3, label=\"Payload Trajectory\") plt.scatter(0, 0, color='red', label=\"Earth\", s=100) plt.title(\"Trajectory of Freely Released Payload Near Earth\") plt.xlabel(\"X Position (km)\") plt.ylabel(\"Y Position (km)\") plt.grid(True) plt.legend() plt.axis('equal') plt.show() Parabolic Trajectory: This plot will show the path of an object with escape velocity from Earth, which will travel outward and return. Elliptical Trajectory: The object follows an elliptical orbit, returning to Earth. Hyperbolic Trajectory: The object escapes Earth's gravitational field, following a hyperbolic path outwards indefinitely. Each graph will also include a yellow dot representing Earth at the origin (0, 0) and will display the trajectory path of the object. The axis('equal') ensures that the axes have the same scaling for accurate representation of the orbital shape. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (Nm^2/kg^2) M_earth = 5.972e24 # Mass of Earth (kg) r_earth = 6.371e6 # Radius of Earth (m) # Initial conditions for each type of trajectory: # 1. Parabolic: Exact escape velocity (7.12 km/s) # 2. Elliptical: A velocity less than escape velocity # 3. Hyperbolic: A velocity greater than escape velocity # Time setup t0 = 0 # Initial time tf = 6000 # Final time (seconds) dt = 10 # Time step (seconds) time_points = np.arange(t0, tf, dt) # Acceleration due to gravity (Newton's Law) def acceleration(position): r = np.linalg.norm(position) return -G * M_earth * position / r**3 # Runge-Kutta method def runge_kutta(position, velocity, dt): k1v = acceleration(position) k1p = velocity k2v = acceleration(position + 0.5 * dt * k1p) k2p = velocity + 0.5 * dt * k1v k3v = acceleration(position + 0.5 * dt * k2p) k3p = velocity + 0.5 * dt * k2v k4v = acceleration(position + dt * k3p) k4p = velocity + dt * k3v new_position = position + (dt / 6) * (k1p + 2*k2p + 2*k3p + k4p) new_velocity = velocity + (dt / 6) * (k1v + 2*k2v + 2*k3v + k4v) return new_position, new_velocity # Define initial conditions for the different types of trajectories # Parabolic trajectory (escape velocity, 7.12 km/s tangential) initial_position_parabolic = np.array([7000e3, 0]) # 7000 km from Earth's center initial_velocity_parabolic = np.array([0, 7.12e3]) # Parabolic velocity (7.12 km/s tangential) # Elliptical trajectory (velocity less than escape velocity, 5 km/s) initial_position_elliptical = np.array([7000e3, 0]) # 7000 km from Earth's center initial_velocity_elliptical = np.array([0, 5e3]) # Elliptical velocity (5 km/s tangential) # Hyperbolic trajectory (velocity greater than escape velocity, 10 km/s) initial_position_hyperbolic = np.array([7000e3, 0]) # 7000 km from Earth's center initial_velocity_hyperbolic = np.array([0, 10e3]) # Hyperbolic velocity (10 km/s tangential) # List to store results for each trajectory type positions_parabolic = [] positions_elliptical = [] positions_hyperbolic = [] # Run simulations for each trajectory def simulate_trajectory(initial_position, initial_velocity): position = initial_position velocity = initial_velocity positions = [] for t in time_points: positions.append(position) position, velocity = runge_kutta(position, velocity, dt) return np.array(positions) # Simulate all three types of trajectories positions_parabolic = simulate_trajectory(initial_position_parabolic, initial_velocity_parabolic) positions_elliptical = simulate_trajectory(initial_position_elliptical, initial_velocity_elliptical) positions_hyperbolic = simulate_trajectory(initial_position_hyperbolic, initial_velocity_hyperbolic) # Plot the results for Parabolic trajectory plt.figure(figsize=(8, 6)) plt.plot(positions_parabolic[:, 0] / 1e3, positions_parabolic[:, 1] / 1e3, label=\"Parabolic Trajectory (Escape Velocity)\", color='blue') plt.scatter(0, 0, color='yellow', label=\"Earth\", s=100) plt.title(\"Parabolic Trajectory (Escape Velocity)\") plt.xlabel(\"X Position (km)\") plt.ylabel(\"Y Position (km)\") plt.grid(True) plt.legend() plt.axis('equal') plt.show() # Plot the results for Elliptical trajectory plt.figure(figsize=(8, 6)) plt.plot(positions_elliptical[:, 0] / 1e3, positions_elliptical[:, 1] / 1e3, label=\"Elliptical Trajectory (Sub-Escape Velocity)\", color='green') plt.scatter(0, 0, color='yellow', label=\"Earth\", s=100) plt.title(\"Elliptical Trajectory (Sub-Escape Velocity)\") plt.xlabel(\"X Position (km)\") plt.ylabel(\"Y Position (km)\") plt.grid(True) plt.legend() plt.axis('equal') plt.show() # Plot the results for Hyperbolic trajectory plt.figure(figsize=(8, 6)) plt.plot(positions_hyperbolic[:, 0] / 1e3, positions_hyperbolic[:, 1] / 1e3, label=\"Hyperbolic Trajectory (Super-Escape Velocity)\", color='red') plt.scatter(0, 0, color='yellow', label=\"Earth\", s=100) plt.title(\"Hyperbolic Trajectory (Super-Escape Velocity)\") plt.xlabel(\"X Position (km)\") plt.ylabel(\"Y Position (km)\") plt.grid(True) plt.legend() plt.axis('equal') plt.show()","title":"\ud83d\udee0\ufe0f Python Implementation"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}